"use strict";(self.webpackChunkimjuni_home=self.webpackChunkimjuni_home||[]).push([[2713],{4781:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(1527),o=t(6274);const i={title:"Async Context",sidebar_position:2},a=void 0,r={id:"backend/node/async_context",title:"Async Context",description:"Background",source:"@site/docs/backend/node/async_context.mdx",sourceDirName:"backend/node",slug:"/backend/node/async_context",permalink:"/imjuni/backend/node/async_context",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Async Context",sidebar_position:2},sidebar:"aboutSidebar",previous:{title:"Design of Entity & DTO",permalink:"/imjuni/backend/node/entity_dto"},next:{title:"JSONSchema",permalink:"/imjuni/opensource/jsonschema/"}},c={},l=[{value:"Background",id:"background",level:2},{value:"Case study of AsyncContext",id:"case-study-of-asynccontext",level:2},{value:"Request ID &amp; Tracking ID",id:"request-id--tracking-id",level:3},{value:"TypeORM with AsyncContext",id:"typeorm-with-asynccontext",level:3},{value:"translate with AsyncContext",id:"translate-with-asynccontext",level:3},{value:"getAsyncStore \ud568\uc218",id:"getasyncstore-\ud568\uc218",level:3},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["This document introduces the ",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-async-context",children:"AsyncContext"})," feature. AsyncContext is a feature in TC39 ",(0,s.jsx)(n.a,{href:"https://tc39.es/process-document/",children:"Stage2"}),". I introduce it because it has been included in the Node.js environment since v12 and continues to be improved in versions like v16, v18, v20, etc."]}),"\n",(0,s.jsx)(n.p,{children:"When running a synchronous function, creating a context before running the function allows the function to maintain and utilize the context while it runs. Synchronous functions can utilize the context because no other functions are executed while it is executed, so the value of the context can be guaranteed if the executing function does not change it, but asynchronous functions cannot guarantee the value of the context because other functions may be executed. Therefore, it is inconvenient to keep passing values such as tracking id, request id, etc. for tracking or settings such as language, cache life cycle, etc. as arguments to the function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const Polyglot = require('node-polyglot');\n\nconst polyglot = {\n  ko: new Polyglot({\n    phrases: {\n      hello_name: '\uc548\ub155\ud558\uc138\uc694! %{name}\ub2d8',\n    },\n  }),\n  en: new Polyglot({\n    phrases: {\n      hello_name: 'Hola %{name}',\n    },\n  }),\n};\n\nfunction child01(lang: string) {\n  return polyglot[lang].t('hello_name', { name: 'hello' });\n}\n\nfunction child02(lang: string) {\n\treturn { message: child01(lang) };\n}\nfunction child03(lang: string) {\n\treturn child02(lang);\n}\nfunction child04(lang: string) {\n\treturn child03();\n}\nfunction child05(lang: string) {\n\treturn child04(lang);\n}\n\nfunction parent(req: FastifyRequest) {\n  const lang = req.headers['accpet-language'];\n\tconst message = child05(lang);\n\treturn { ...message, id: 1 };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In the example above, the parent function uses the child05 function to get the message value, but the child05 function actually runs several other functions to get the message."}),"\n",(0,s.jsx)(n.mermaid,{value:'---\ntitle: simulation of the function call-stacks\n---\nflowchart LR\n    P01["parent(req)"] --\x3e C05["child05(lang)"]\n    C05 --\x3e |lang| C04["child04(lang)"]\n    C04 --\x3e |lang| C03["child03(lang)"]\n    C03 --\x3e |lang| C02["child02(lang)"]\n    C02 --\x3e |lang| C01["child01(lang)"]\n    C01 -.-> C02\n    C02 -.-> C03\n    C03 -.-> C04\n    C04 -.-> C05\n    C05 -.-> P01'}),"\n",(0,s.jsx)(n.p,{children:"In the example code above, you can see that child02, child03, child04, and child05 don't use the language argument value, but the lang value is still passed as an argument to the child01 function to pass the language value. However, we can easily change this structure by utilizing context."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { AsyncLocalStorage, AsyncResource } = require('async_hooks');\nconst store = new AsyncLocalStorage();\nconst Polyglot = require('node-polyglot');\n\nconst polyglot = {\n  ko: new Polyglot({\n    phrases: {\n      hello_name: '\uc548\ub155\ud558\uc138\uc694! %{name}\ub2d8',\n    },\n  }),\n  en: new Polyglot({\n    phrases: {\n      hello_name: 'Hola %{name}',\n    },\n  }),\n};\n\nasync function child01() {\n  const currentStore = store.getStore();\n  console.log('language: ', currentStore.lang);\n  return polyglot[currentStore.lang].t('hello_name', { name: 'hello' });\n}\n\nasync function child02() {\n  return { message: await child01() };\n}\nasync function child03() {\n  return child02();\n}\nasync function child04() {\n  return child03();\n}\nasync function child05() {\n  return child04();\n}\n\nasync function parent(req) {\n  const lang = req.headers['accpet-language'];\n\n  const result = store.run({ lang }, async () => {\n    const resource = new AsyncResource('fastify-async-context');\n    return resource.runInAsyncScope(async () => {\n      const message = await child05(lang);\n      return { ...message, id: 1 };\n    });\n  });\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example, unlike before, you can see that the lang value is not passed as an argument to the child01, child02, child03, child04, and child05 functions. Even though it is not passed as an argument, you can see that the child01 function uses AsyncContext to read the language value."}),"\n",(0,s.jsx)(n.mermaid,{value:'---\ntitle: simulation of the function call-stacks\n---\nflowchart LR\n    P01["parent(req)"] --\x3e C05["child05(lang)"]\n    P01 --\x3e |lang| S01[AsyncLocaStorage]\n    C05 --\x3e C04["child04(lang)"]\n    C04 --\x3e C03["child03(lang)"]\n    C03 --\x3e C02["child02(lang)"]\n    C02 --\x3e C01["child01(lang)"]\n    S01 --\x3e |lang| C01\n    C01 -.-> C02\n    C02 -.-> C03\n    C03 -.-> C04\n    C04 -.-> C05\n    C05 -.-> P01'}),"\n",(0,s.jsx)(n.p,{children:"You can expect to be more productive and better able to utilize a variety of data because you won't have to keep passing AsyncContext the information it needs as function arguments."}),"\n",(0,s.jsx)(n.h2,{id:"case-study-of-asynccontext",children:"Case study of AsyncContext"}),"\n",(0,s.jsxs)(n.p,{children:["I'm going to describe in more detail my experience using AsyncContext in a useful way. However, browsers don't support AsyncContext yet, so we have to use alternatives like ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/zone.js",children:"zone.js"}),". So let's take a look at how we can utilize AsyncContext in a Node.js environment."]}),"\n",(0,s.jsx)(n.h3,{id:"request-id--tracking-id",children:"Request ID & Tracking ID"}),"\n",(0,s.jsx)(n.p,{children:"Giving every request a unique ID is useful for analyzing problems in case of failures, bugs, etc. fastify.js provides the ability to generate Request IDs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const tidSymbol = Symbol('tid')\nconst fastify = require('fastify');\nconst server = fastify({ \n  genReqId: (req) => {\n    const tid = randomUUID();\n    req[tidSymbol] = tid;\n\treturn tid;\n} });\n"})}),"\n",(0,s.jsx)(n.p,{children:"The request is now given a unique UUID, and once we have this UUID, we can track the request. Let's make it a little more useful. Store the UUID in the AsyncContext."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const fastify = require('fastify');\nconst { AsyncResource, executionAsyncId } = require('async_hooks');\nconst  { fastifyRequestContext } = require('@fastify/request-context');\nconst crypto = require('crypto');\n\nconst tidSymbol = Symbol('fastify-request-context-tracking-id')\nconst resourceType = 'fastify-request-context';\n\n// Create fastify server with request ID generator\nconst server = fastify({ \n  genReqId: (req) => {\n    const tid = crypto.randomUUID();\n    req[tidSymbol] = tid;\n    return tid;\n  } \n});\n\nserver.register(fastifyRequestContext, {\n  defaultStoreValues: (req) => ({\n    tid: req.id,\n    lang: req.headers['accept-language'],\n    type: resourceType,\n    triggerAsyncId: executionAsyncId(),\n  }),\n  createAsyncResource: () => new AsyncResource(resourceType),\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we can access ",(0,s.jsx)(n.code,{children:"req.id"})," from every fastify request handlers, and use ",(0,s.jsx)(n.code,{children:"AsyncContext"})," in other functions to extract the request ID."]}),"\n",(0,s.jsx)(n.h3,{id:"typeorm-with-asynccontext",children:"TypeORM with AsyncContext"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://typeorm.io/",children:"TypeORM"})," is a library that allows various databases to be used in the Node.js environment. ORM libraries provide the ability to log the queries they execute. TypeORM also provides the feature to log all queries, slow queries, query errors, and more. Combining the logging features with the Request ID mentioned earlier makes for a useful log."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { AbstractLogger } from \"typeorm\"\n\nexport class MyCustomLogger extends AbstractLogger {\n  /**\n   * Write log to specific output.\n  */\n  protected writeLog(\n        level: LogLevel,\n        logMessage: LogMessage | LogMessage[],\n        queryRunner?: QueryRunner,\n    ) {\n        // implementation of writeLog ...\n\t}\n\t\n\t/**\n   * Logs query that is slow.\n   */\n  logQuerySlow(time: number, query: string, parameters?: unknown[], _queryRunner?: QueryRunner) {\n    if (isFalse(this.isLogEnabledFor('query-slow'))) {\n      return;\n    }\n\n\t  const store = getAsyncStore();\n\t  console.log(`[${store.tid ?? randomUUID()}][${time}]show query: `, query, parameters);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The example above logs the slow query with a tid, where tid is the ",(0,s.jsx)(n.code,{children:"request.id"})," you stored in AsyncLocalStorage before. This allows you to quickly track which APIs are causing the slow queries, and is useful for planning fixes by knowing how often your APIs are being called."]}),"\n",(0,s.jsx)(n.h3,{id:"translate-with-asynccontext",children:"translate with AsyncContext"}),"\n",(0,s.jsxs)(n.p,{children:["I use the i18n library to create multilingual messages. I use ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/node-polyglot",children:"node-polyglot"}),", which requires me to decide which language to use before using the translate function. To determine the language, I have to keep passing the language to different functions, as mentioned in the background, and this is where AsyncContext can be used to simplify the process."]}),"\n",(0,s.jsx)(n.h3,{id:"getasyncstore-\ud568\uc218",children:"getAsyncStore \ud568\uc218"}),"\n",(0,s.jsxs)(n.p,{children:["We've seen situations where it's useful to use AsyncContext, so let's see how we can get AsyncLocalStorage. There are two ways you can get AsyncLocalStorage. The first way is to use Hooks to create a copy of the AsyncResource when it is created and destroyed. This approach is explained in ",(0,s.jsx)(n.a,{href:"https://blog.besson.co/nodejs_async_hooks_to_get_per_request_context/",children:"Getting per-request context in NodeJS with async_hooks\n"}),". The second method is to use ",(0,s.jsx)(n.code,{children:"executionAsyncResource"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { executionAsyncResource } from 'node:async_hooks';\nimport { randomUUID } from 'node:crypto';\n\nexport function getAsyncStore(): { [key: string]: unknown } {\n  const acquiredExecutionAsyncResource = executionAsyncResource() as {\n    [key: string | symbol]: unknown;\n  };\n  const keys = Object.getOwnPropertySymbols(acquiredExecutionAsyncResource);\n  const store = keys\n    .map((key) => acquiredExecutionAsyncResource[key])\n    .find((element): element is { tid: string } => typeof element === 'object' && element != null);\n\n  if (store?.tid == null) {\n    return `unde${randomUUID().substring(4)}`;\n  }\n\n  return store.tid;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertySymbols"})," function to extract the key of the AsyncResource, and that way you can get the AsyncLocalStorage. It doesn't matter which method you choose, but in my personal experience, the first method sometimes doesn't retrieve the AsyncLocalStorage, so if you want it to work every time, I recommend using the second method."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["AsyncContext is still in Stage 2, and if you look at the official Node.js ",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/async_hooks.html",children:"reference documentation"}),", each version has a slightly different implementation, so it may be difficult to use if you are using Node.js v16 or lower. Also, the specification may change because it is in Stage 2. Nevertheless, AsyncContext is attractive. It's very useful to be able to get a common value from somewhere without having to add all the arguments to a function, so if you're building a new environment or using Node.js v16 or later, you should definitely take a look at it. Thank you for reading the documentation so far!"]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);