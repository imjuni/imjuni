"use strict";(self.webpackChunkimjuni_home=self.webpackChunkimjuni_home||[]).push([[2110],{1997:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var s=i(1527),n=i(6274);const r={sidebar_position:2,title:"In-Depth guide for TypeScript Library Project"},o=void 0,a={id:"typescript/library",title:"In-Depth guide for TypeScript Library Project",description:"Background",source:"@site/docs/typescript/library.md",sourceDirName:"typescript",slug:"/typescript/library",permalink:"/imjuni/typescript/library",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"In-Depth guide for TypeScript Library Project"},sidebar:"aboutSidebar",previous:{title:"ctix - barrel file generator using TypeScript Compiler API",permalink:"/imjuni/typescript/ctix"}},l={},h=[{value:"Background",id:"background",level:2},{value:"What&#39;s the problem?",id:"whats-the-problem",level:2},{value:"Barrel file, edit over and over again",id:"barrel-file-edit-over-and-over-again",level:3},{value:"Can I use paths re-maps?",id:"can-i-use-paths-re-maps",level:3},{value:"bundling for <code>.d.ts</code>",id:"bundling-for-dts",level:3},{value:"How can we solve it?",id:"how-can-we-solve-it",level:2},{value:"Automatically generate a barrel file",id:"automatically-generate-a-barrel-file",level:3},{value:"<code>.d.ts</code> bundling",id:"dts-bundling",level:3},{value:"default export, export",id:"default-export-export",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(t.p,{children:"It's a common approach in development projects to separate common business logic into functions or classes within the same project for reuse. As a project grows in size, some logic may be more efficiently isolated into separate packages and used in other projects. In my experience, functions like login, logout, and logging are easier to maintain and adapt in the long run if they are separated into separate library packages. I've reviewed several articles on writing library packages, but here I'm going to summarize some of the more specialized topics that aren't covered in those articles."}),"\n",(0,s.jsx)(t.h2,{id:"whats-the-problem",children:"What's the problem?"}),"\n",(0,s.jsx)(t.h3,{id:"barrel-file-edit-over-and-over-again",children:"Barrel file, edit over and over again"}),"\n",(0,s.jsxs)(t.p,{children:["To simplify the ",(0,s.jsx)(t.code,{children:"import"})," syntax, the file that holds the ",(0,s.jsx)(t.code,{children:"export"})," syntax is called a ",(0,s.jsx)(t.a,{href:"https://basarat.gitbook.io/typescript/main-1/barrel",children:"barrel file"}),"."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"barrel file"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export { Button } from './button/index.ts'\nexport { Accordion } from './accordion/index.ts'\nexport { Notification } from './notification/index.ts'\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"other file"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { Button } from '../../src'\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Barrel files are commonly found in component library projects. For example, you can find a ",(0,s.jsx)(t.a,{href:"https://github.com/mantinedev/ui.mantine.dev/blob/master/lib/index.ts",children:"Barrel file"})," in the ",(0,s.jsx)(t.a,{href:"https://github.com/mantinedev/ui.mantine.dev",children:"Mantine"})," project. Since there are often no dependencies between each component or feature in a library project, it often happens that the bundler does not include all the files even when using a dependency graph. This is where the barrel file comes into handy. By specifying the barrel file in the main and module fields of the ",(0,s.jsx)(t.code,{children:"package.json"})," file, it also serves as a point of execution for the Node.js interpreter or the browser's script tag. Barrel files are often written by developers themselves because they fulfill an important function."]}),"\n",(0,s.jsxs)(t.p,{children:["However, it is a big challenge for developers to write barrel files themselves. In projects like ",(0,s.jsx)(t.a,{href:"https://github.com/mantinedev/ui.mantine.dev",children:"Mantine"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/date-fns/date-fns",children:"date-fns"}),", which are already very large, it is not easy to write a barrel file every time there is a change, and if it is included in a VCS(e.g. ",(0,s.jsx)(t.code,{children:"git"}),"), it increases the probability of conflicts when multiple developers collaborate. Therefore, I thought there is a need for a way to automatically generate barrel files based on certain rules and not include them in a VCS."]}),"\n",(0,s.jsx)(t.h3,{id:"can-i-use-paths-re-maps",children:"Can I use paths re-maps?"}),"\n",(0,s.jsx)(t.p,{children:"To import classes, functions, constants, etc. from another script in TypeScript and JavaScript, you need to enter the relative path to the script you want to call from the current script."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import chunkArray from '../../tools/array/chunkArray';\n\nasync function getBulkInsertFruit(fruits: string[]) {\n  await Promise.all(chunkArray(fruits, 5).map(async (chunk) => insert(chunk)));\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the example code above, you can see that we imported the function with a relative path. Using relative paths is inconvenient because the import statement is always different. Using a barrel file doesn't improve things much, and it's a difficult problem to solve without the help of an IDE. That's why TypeScript provides the ",(0,s.jsx)(t.a,{href:"https://www.typescriptlang.org/tsconfig#paths",children:"Paths Re-Map"})," feature."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import chunkArray from '#/tools/array/chunkArray';\n\nasync function getBulkInsertFruit(fruits: string[]) {\n  await Promise.all(chunkArray(fruits, 5).map(async (chunk) => insert(chunk)));\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If you look at the example code above, you can see that we've imported the ",(0,s.jsx)(t.code,{children:"chunkArray"})," function as if we were using an absolute path. This feature allows you to use the same import statement for all your files and reduces the amount of work when refactoring to change paths or filenames. However, since this feature is not provided by ECMA Script, it creates a number of problems: not only do you have to tell your test frameworks like jest and vitest to set up Paths Re-Map, but you also have to tell your bundlers about it. It also affects the bundling of ",(0,s.jsx)(t.code,{children:".d.ts"})," files, which we will discuss in the next chapter. Since this issue is the same for library packages and applications alike, we also need a way to work around it."]}),"\n",(0,s.jsxs)(t.h3,{id:"bundling-for-dts",children:["bundling for ",(0,s.jsx)(t.code,{children:".d.ts"})]}),"\n",(0,s.jsxs)(t.p,{children:["In order for a TypeScript-based library package to be used by other TypeScript projects, it is necessary to provide the type files (.d.ts) along with the JavaScript files. To do this, the ",(0,s.jsx)(t.code,{children:"types"})," field in the ",(0,s.jsx)(t.code,{children:"package.json"})," file sets the entry point for the type files. However, there is no official way to effectively bundle type files. There was a ",(0,s.jsx)(t.a,{href:"https://github.com/Microsoft/TypeScript/issues/4433",children:"discussion"})," about this, but the issue was closed without a clear solution to the problem."]}),"\n",(0,s.jsxs)(t.p,{children:["Using TypeScript's Paths Re-Map feature further complicates matters. TypeScript has ",(0,s.jsx)(t.a,{href:"https://github.com/microsoft/TypeScript/issues/5039",children:"defined module renaming for Paths Re-Mapped modules as the role of the bundler"}),", which means that when using Paths Re-Map, providing a type file requires you to do two things: convert the Paths Re-Map of that type file to a relative path and bundle it. This can make it difficult for library package developers to efficiently manage and ship type files."]}),"\n",(0,s.jsx)(t.h2,{id:"how-can-we-solve-it",children:"How can we solve it?"}),"\n",(0,s.jsx)(t.p,{children:"If you don't use bundlers and Paths Re-Map, you can avoid the issues involved. However, you'll still need to manually write your barrel files, and as your library package grows in size, it can be inefficient to use only the basic functionality. So, let's take a look at how you can solve the problem."}),"\n",(0,s.jsx)(t.h3,{id:"automatically-generate-a-barrel-file",children:"Automatically generate a barrel file"}),"\n",(0,s.jsxs)(t.p,{children:["I've been working on automating barrel files for a long time, and in the process have developed ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"}),". The 1.x version had some inconveniences, but with the 2.x version, I've improved these issues and made it more user-friendly. ctix uses the TypeScript Compiler API to automatically generate barrel files by extracting statements containing the ",(0,s.jsx)(t.code,{children:"export"})," keyword. The advantage of ctix is that barrel files are automatically generated, so you don't have to manage them separately in your version control system (VCS), e.g. git. It also has the advantage of always generating compilable barrel files because it uses the TypeScript Compiler API to extract only ",(0,s.jsx)(t.code,{children:"export"})," statements."]}),"\n",(0,s.jsxs)(t.h3,{id:"dts-bundling",children:[(0,s.jsx)(t.code,{children:".d.ts"})," bundling"]}),"\n",(0,s.jsxs)(t.p,{children:["This is a really hard problem. For now, there are ",(0,s.jsx)(t.a,{href:"https://github.com/Microsoft/TypeScript/issues/4433",children:"discussions"})," going on within the TypeScript community to resolve this issue, but they are inconclusive, and have been for a long time. So we need to use external tools to solve this problem. Currently, the popular ",(0,s.jsx)(t.code,{children:".d.ts"})," bundling tools are as follows"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://api-extractor.com/",children:"API Extractor"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/wessberg/rollup-plugin-ts",children:"rollup-plugin-ts"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/jeremyben/tsc-prog",children:"tsc-prog"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["There are many more tools than those listed above. You can check out ",(0,s.jsx)(t.a,{href:"https://github.com/Microsoft/TypeScript/issues/4433",children:"discussion"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator/discussions/68",children:"comparison"})," of bundling tools. Unfortunately, choosing the right tool among them is a process that you'll have to experiment with and decide for your own project needs. For example, ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"}),", ",(0,s.jsx)(t.a,{href:"https://api-extractor.com/",children:"API Extractor"}),", and ",(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})," do not support ",(0,s.jsx)(t.code,{children:".d.ts.map"})," files. Also, ",(0,s.jsx)(t.a,{href:"https://api-extractor.com/",children:"API Extractor"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"})," do not have chunking capabilities, ",(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})," is currently in maintenance mode, and the ",(0,s.jsx)(t.code,{children:"default export"})," and ",(0,s.jsx)(t.code,{children:"export"})," statements differ in the way different bundlers generate output. Therefore, you should carefully select and use the most appropriate tool based on your project's configuration."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"})," is a lightweight and easy tool. If you pass a barrel file generated using ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"})," to ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"})," and just specify the path to the output file, it will work fine in most cases without any additional setup. However, if you are using the latest version of ",(0,s.jsx)(t.a,{href:"https://fastify.dev/",children:"Fastify.js"})," in your backend development, you may encounter an issue where bundling fails because ",(0,s.jsx)(t.code,{children:"Symbol.asyncDispose"})," is not found. This is due to the way the ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator",children:"dts-bundle-generator"})," loads only necessary modules for performance optimization, which prevents it from loading some ",(0,s.jsx)(t.code,{children:".d.ts"})," files. There is a ",(0,s.jsx)(t.a,{href:"https://github.com/timocov/dts-bundle-generator/discussions/232",children:"workaround"})," being discussed for this, but it didn't work in my case. Nevertheless, the tool generally works well and is easy to use with a few simple option settings, and I recommend testing in a live environment if you are considering adopting it."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})," is a plugin that is currently in maintenance mode, but still works well. However, this plugin only performs bundling correctly for ",(0,s.jsx)(t.code,{children:".d.ts"})," files that do not use Paths Re-Map. By the way, even if you create a ",(0,s.jsx)(t.code,{children:".d.ts"})," file using ",(0,s.jsx)(t.a,{href:"https://github.com/rollup/plugins/tree/master/packages/typescript",children:"@rollup/plugin-typescript"}),", this does not fully resolve Paths Re-Map. For this, you need to use ",(0,s.jsx)(t.a,{href:"https://github.com/justkey007/tsc-alias",children:"tsc-alias"})," to resolve Paths Re-Map issues. After resolving Paths Re-Map, bundling with ",(0,s.jsx)(t.a,{href:"https://github.com/wessberg/rollup-plugin-ts",children:"rollup-plugin-ts"})," works well to generate a ",(0,s.jsx)(t.code,{children:".d.ts"})," file. However, even with this method, the ability to generate ",(0,s.jsx)(t.code,{children:".map"})," files and the ",(0,s.jsx)(t.code,{children:"chunking"})," feature is not available. Given that library projects are often bundled as part of JavaScript projects, I think these limitations are acceptable."]}),"\n",(0,s.jsxs)(t.p,{children:["I use ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"})," for barrel file generation and ",(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/justkey007/tsc-alias",children:"tsc-alias"})," for bundling. However, this method may not be suitable for monorepos consisting of multiple packages or if the ",(0,s.jsx)(t.code,{children:"composite"})," option is set in ",(0,s.jsx)(t.code,{children:"tsconfig"}),". Before introducing ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"})," or ",(0,s.jsx)(t.code,{children:".d.ts"})," bundling tools to your ongoing library packages, it is important to test them and make sure they are suitable before applying them."]}),"\n",(0,s.jsx)(t.h3,{id:"default-export-export",children:"default export, export"}),"\n",(0,s.jsxs)(t.p,{children:["There has been some ",(0,s.jsx)(t.a,{href:"https://github.com/airbnb/javascript/issues/1365",children:"discussion"})," about the use of ",(0,s.jsx)(t.code,{children:"default export"})," vs ",(0,s.jsx)(t.code,{children:"export"}),", but it's hard to conclude unequivocally that one is better. For example, ",(0,s.jsx)(t.a,{href:"https://github.com/airbnb/javascript#modules--prefer-default-export",children:"eslint-config-airbnb"})," recommends using ",(0,s.jsx)(t.code,{children:"default export"}),". However, when developing ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"})," and using the TypeScript Compiler API, I noticed that all of the ",(0,s.jsx)(t.code,{children:"default export"}),"s were named ",(0,s.jsx)(t.code,{children:"default"}),". Since all of the import statements in a barrel file are collected in one place, duplicate names can cause problems. The ",(0,s.jsx)(t.code,{children:"default export"})," is similar to an anonymous export because it has the same name. If the original statement has a name, you can use the ",(0,s.jsx)(t.code,{children:"alias"})," keyword to give it the original name, but since different ",(0,s.jsx)(t.code,{children:".d.ts"})," bundlers handle aliases differently, the result may not be what you intended."]}),"\n",(0,s.jsxs)(t.p,{children:["Thus, ",(0,s.jsx)(t.code,{children:"default export"})," can cause complicated syntax issues in library packages that need to be used by other projects. Because different bundling tools work differently, and because developers have different preferences on how to handle them, I believe that ",(0,s.jsx)(t.code,{children:"default export"})," should only be used in components that cannot be handled by TypeScript, such as Vue and Svelte. In other cases, using ",(0,s.jsx)(t.code,{children:"export"})," minimizes the chance of problems."]}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["Library package projects are useful when developing. With ",(0,s.jsx)(t.a,{href:"http://npmjs.com/",children:"npm"}),", there are tons of library packages available. I've been creating and using libraries out of necessity, and in doing so, I've felt the need to organize how I go about scaffolding my library package projects. There's a lot of good material out there about setting up bundlers and overall scaffolding, but topics like Paths Re-Map and ",(0,s.jsx)(t.code,{children:".d.ts"})," bundling are relatively uninformed, so I've put together some thoughts on that. The following is by no means a definitive answer, but it's the way I apply it when working on library projects."]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Automatically generate an barrel file using ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/ctix",children:"ctix"})]}),"\n",(0,s.jsxs)(t.li,{children:["Bundling ",(0,s.jsx)(t.code,{children:".d.ts"})," files using ",(0,s.jsx)(t.a,{href:"https://github.com/Swatinem/rollup-plugin-dts",children:"rollup-plugin-dts"})," and ",(0,s.jsx)(t.a,{href:"https://github.com/justkey007/tsc-alias",children:"tsc-alias"})]}),"\n",(0,s.jsxs)(t.li,{children:["Bundling with ",(0,s.jsx)(t.a,{href:"https://esbuild.github.io/",children:"esbuild"})]}),"\n",(0,s.jsxs)(t.li,{children:["use ",(0,s.jsx)(t.a,{href:"https://vitest.dev/",children:"vitest"})," or ",(0,s.jsx)(t.a,{href:"https://jestjs.io/",children:"jest"})," as a test runner","\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["use ",(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/vite-tsconfig-paths",children:"vite-tsconfig-paths"})," to pass ",(0,s.jsx)(t.a,{href:"https://kulshekhar.github.io/ts-jest/docs/getting-started/paths-mapping/",children:"Paths Re-Map"})]}),"\n",(0,s.jsxs)(t.li,{children:["use ",(0,s.jsx)(t.a,{href:"https://kulshekhar.github.io/ts-jest/",children:"ts-jest"})," and set up ",(0,s.jsx)(t.a,{href:"https://kulshekhar.github.io/ts-jest/docs/getting-started/paths-mapping/",children:"Paths Re-Map"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["I've uploaded the ",(0,s.jsx)(t.a,{href:"https://github.com/imjuni/typescript-lib-boilerplate",children:"typescript-lib-boilerplate"})," repo.for your reference. How do you guys work when developing library projects? If you have any good tips, please let me know, thanks!"]})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);